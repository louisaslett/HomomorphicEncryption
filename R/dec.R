#' Decrypt a ciphertext
#' 
#' This decrypts an integer message which has been encrypted under one of the 
#' homomorphic schemes supported by this package.
#' 
#' Note that the scheme specified by the private key, \code{sk}, and the ciphertext,
#' \code{ct}, must match.
#' 
#' If a symmetric key scheme is being used, then the secret key should be provided
#' for the \code{sk} argument.
#' 
#' @param pk a private key for any scheme as generated by the \code{\link{keygen}}.
#' function.
#' 
#' @param ct a ciphertext as produced from a call to \code{\link{enc}}.
#' 
#' @return
#' The decrypted integer message.
#' 
#' @seealso
#' \code{\link{enc}} to encrypt messages to ciphertexts which this function decrypts.
#' 
#' @examples
#' p <- pars("FandV")
#' keys <- keygen(p)
#' ct <- enc(keys$pk, 1)
#' dec(keys$sk, ct)
#' 
#' @author Louis Aslett
dec <- function(sk, ct) {
  if(is.null(attr(ct, "FHEt")) || (attr(ct, "FHEt")!="ct" && attr(ct, "FHEt")!="ctvec")) stop("ct argument does not contain a cipher text.")
  if(is.null(attr(sk, "FHEt")) || attr(sk, "FHEt")!="sk") stop("sk argument is not a secret key.")
  if(is.null(attr(ct, "FHEs")) || is.null(attr(sk, "FHEs")) || attr(ct, "FHEs")!=attr(sk, "FHEs")) stop("Mismatch between cryptographic scheme specified by key and cipher text.")
  UseMethod("dec", sk)
}

dec.Rcpp_FandV_sk <- function(sk, ct) {
  if(class(ct) == "Rcpp_FandV_ct") {
    return(sk$dec(ct))
  } else {
    res <- sk$dec(ct[1])
    
    for(i in 2:ct$size()) {
      res <- c(res, sk$dec(ct[i]))
    }
    
    return(res)
  }
}
