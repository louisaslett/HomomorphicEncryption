#' Decrypt a ciphertext
#' 
#' This decrypts an integer message which has been encrypted under one of the 
#' homomorphic schemes supported by this package.
#' 
#' Note that the scheme specified by the private key, \code{sk}, and the ciphertext,
#' \code{ct}, must match.
#' 
#' If a symmetric key scheme is being used, then the secret key should be provided
#' for the \code{sk} argument.
#' 
#' @param sk a private/secret key for any scheme as generated by the \code{\link{keygen}}.
#' function.
#' 
#' @param ct a ciphertext as produced from a call to \code{\link{enc}}.
#' 
#' @return
#' The decrypted integer message.  If the value is in the range of a standard
#' integer in R (-2147483647 to 2147483647) then an integer will be returned,
#' otherwise a \code{\link[gmp]{bigz}} big integer object from the gmp package
#' will be returned.
#' 
#' @seealso
#' \code{\link{enc}} to encrypt messages to ciphertexts which this function decrypts.
#' 
#' @examples
#' p <- pars("FandV")
#' keys <- keygen(p)
#' ct <- enc(keys$pk, 1)
#' dec(keys$sk, ct)
#' 
#' @author Louis Aslett
dec <- function(sk, ct) {
  if(is.null(attr(ct, "FHEt")) || (attr(ct, "FHEt")!="ct" && attr(ct, "FHEt")!="ctvec")) stop("ct argument does not contain a cipher text.")
  if(is.null(attr(sk, "FHEt")) || attr(sk, "FHEt")!="sk") stop("sk argument is not a secret key.")
  if(is.null(attr(ct, "FHEs")) || is.null(attr(sk, "FHEs")) || attr(ct, "FHEs")!=attr(sk, "FHEs")) stop("Mismatch between cryptographic scheme specified by key and cipher text.")
  UseMethod("dec", sk)
}

dec.Rcpp_FandV_sk <- function(sk, ct) {
  if(class(ct) == "Rcpp_FandV_ct") {
    res <- as.bigz(sk$dec(ct))
    if(res < 2147483647 && res > -2147483647)
      return(as.integer(res))
    else
      return(res)
  } else {
    res <- as.bigz(sk$dec(ct[1]))
    
    for(i in 2:ct$size()) {
      res <- c(res, as.bigz(sk$dec(ct[i])))
    }
    
    if(sum(res > 2147483647 | res < -2147483647) == 0)
      return(as.integer(res))
    else
      return(res)
  }
}
